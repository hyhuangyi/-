								单例

*static: 静态变量被所有该类的对象所共享，比如在Person类中有一静态变量age，其有两个实例tom,jack，那么，tom和jack共享同一个age，
也就是说这两个人，无论哪一个修改了age字段，都会导致另外一个人的age字段被修改。

--------------------------------------------------------------------------------------------------------------------------------------

*当一个类的实例可以有且只可以一个的时候就需要用到了。为什么只需要有一个呢?有人说是为了节约内存，但这只是单例模式带来的一个好处。

只有一个实例确实减少内存占用，可是我认为这不是使用单例模式的理由。我认为使用单例模式的时机是当实例存在多个会引起程序逻辑错误的时候。

比如类似有序的号码生成器这样的东西，怎么可以允许一个应用上存在多个呢?

*Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。

---------------------------------------------------------------------------------------------------------------------------------------

一般Singleton模式通常有三种形式:

第一种形式:懒汉式，也是常用的形式。

第二种形式:饿汉式

第三种形式: 双重锁的形式。饿汉式变种


*单例模式的要点有三个;一是某个类只能有一个实例;二是它必须自行创建这个实例;三是它必须自行向整个系统提供这个实例。

从具体实现角度来说，就是以下三点:一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，

三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。

------------------------------------------------------------------------------------------------------------------------------------------
1.饿汉式单例类

//饿汉式单例类.在类初始化时，已经自行实例化 //线程安全
public class Singleton1 {
    //私有的默认构造子
    private Singleton1() {}
    //已经自行实例化 
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法 
    public static Singleton1 getInstance() {
        return single;
    }
}
2.懒汉式单例类

//懒汉式单例类.在第一次调用的时候实例化 //会出现同步问题，方法上加锁
public class Singleton2 {
    //私有的默认构造子
    private Singleton2() {}
    //注意，这里没有final    
    private static Singleton2 single=null;
    //静态工厂方法 
    public synchronized  static Singleton2 getInstance() {
         if (single == null) {  
             single = new Singleton2();
         }  
        return single;
    }
    /*
	//性能更优//双重锁
	public static Singleton2 getInstance() {
        if (single == null) {
            synchronized (Singleton2.class) {
                if (single == null) {
                    single = new Singleton2();
                }
            }

        }
        return single;

    }

	*/
}